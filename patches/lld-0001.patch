From ece347fc2af075b7149776c301ec59825868f969 Mon Sep 17 00:00:00 2001
From: Martell Malone <martellmalone@gmail.com>
Date: Tue, 22 Aug 2017 10:11:15 +0300
Subject: [PATCH] COFF: Introduce LD shim around LINK

---
This patch is up for review at https://reviews.llvm.org/D33880.
---
 CMakeLists.txt              |   1 +
 ELF/Driver.cpp              |   8 +-
 MinGW/CMakeLists.txt        |  20 +++++
 MinGW/Driver.cpp            | 205 ++++++++++++++++++++++++++++++++++++++++++++
 MinGW/Options.td            |  38 ++++++++
 include/lld/Driver/Driver.h |   5 ++
 test/COFF/out.test          |   5 ++
 tools/lld/CMakeLists.txt    |   1 +
 tools/lld/lld.cpp           |  12 +++
 9 files changed, 289 insertions(+), 6 deletions(-)
 create mode 100644 MinGW/CMakeLists.txt
 create mode 100644 MinGW/Driver.cpp
 create mode 100644 MinGW/Options.td

diff --git a/CMakeLists.txt b/CMakeLists.txt
index e2ab0e3..1893e6b 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -221,4 +221,5 @@ endif()
 add_subdirectory(docs)
 add_subdirectory(COFF)
 add_subdirectory(ELF)
+add_subdirectory(MinGW)
 
diff --git a/ELF/Driver.cpp b/ELF/Driver.cpp
index b0962c7..ee86569 100644
--- a/ELF/Driver.cpp
+++ b/ELF/Driver.cpp
@@ -113,12 +113,8 @@ static std::tuple<ELFKind, uint16_t, uint8_t> parseEmulation(StringRef Emul) {
           .Case("elf_iamcu", {ELF32LEKind, EM_IAMCU})
           .Default({ELFNoneKind, EM_NONE});
 
-  if (Ret.first == ELFNoneKind) {
-    if (S == "i386pe" || S == "i386pep" || S == "thumb2pe")
-      error("Windows targets are not supported on the ELF frontend: " + Emul);
-    else
-      error("unknown emulation: " + Emul);
-  }
+  if (Ret.first == ELFNoneKind)
+    error("unknown emulation: " + Emul);
   return std::make_tuple(Ret.first, Ret.second, OSABI);
 }
 
diff --git a/MinGW/CMakeLists.txt b/MinGW/CMakeLists.txt
new file mode 100644
index 0000000..32992bc
--- /dev/null
+++ b/MinGW/CMakeLists.txt
@@ -0,0 +1,20 @@
+set(LLVM_TARGET_DEFINITIONS Options.td)
+tablegen(LLVM Options.inc -gen-opt-parser-defs)
+add_public_tablegen_target(ShimOptionsTableGen)
+
+if(NOT LLD_BUILT_STANDALONE)
+  set(tablegen_deps intrinsics_gen)
+endif()
+
+add_lld_library(lldMinGW
+  Driver.cpp
+
+  LINK_LIBS
+  lldConfig
+  lldCore
+  ${LLVM_PTHREAD_LIB}
+
+  DEPENDS
+  ShimOptionsTableGen
+  ${tablegen_deps}
+)
diff --git a/MinGW/Driver.cpp b/MinGW/Driver.cpp
new file mode 100644
index 0000000..7df3cc0
--- /dev/null
+++ b/MinGW/Driver.cpp
@@ -0,0 +1,205 @@
+//===- MinGW/Driver.cpp ---------------------------------------------------===//
+//
+//                             The LLVM Linker
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+///
+/// GNU ld style linker driver for COFF currently supporting mingw-w64.
+///
+//===----------------------------------------------------------------------===//
+
+#include "lld/Driver/Driver.h"
+#include "llvm/ADT/ArrayRef.h"
+#include "llvm/ADT/Optional.h"
+#include "llvm/ADT/StringRef.h"
+#include "llvm/ADT/StringSwitch.h"
+#include "llvm/ADT/Triple.h"
+#include "llvm/Option/Arg.h"
+#include "llvm/Option/ArgList.h"
+#include "llvm/Option/Option.h"
+#include "llvm/Support/CommandLine.h"
+#include "llvm/Support/FileSystem.h"
+#include "llvm/Support/Path.h"
+#include "llvm/Support/StringSaver.h"
+
+#if !defined(_MSC_VER) && !defined(__MINGW32__)
+#include <unistd.h>
+#endif
+
+using namespace lld;
+using namespace llvm;
+
+namespace lld {
+namespace mingw {
+namespace {
+
+// Create OptTable
+enum {
+  OPT_INVALID = 0,
+#define OPTION(_1, _2, ID, _4, _5, _6, _7, _8, _9, _10, _11, _12) OPT_##ID,
+#include "Options.inc"
+#undef OPTION
+};
+
+// Create prefix string literals used in Options.td
+#define PREFIX(NAME, VALUE) const char *const NAME[] = VALUE;
+#include "Options.inc"
+#undef PREFIX
+
+// Create table mapping all options defined in Options.td
+static const opt::OptTable::Info infoTable[] = {
+#define OPTION(X1, X2, ID, KIND, GROUP, ALIAS, X7, X8, X9, X10, X11, X12)      \
+  {X1, X2, X10,         X11,         OPT_##ID, opt::Option::KIND##Class,       \
+   X9, X8, OPT_##GROUP, OPT_##ALIAS, X7,       X12},
+#include "Options.inc"
+#undef OPTION
+};
+
+class COFFLdOptTable : public opt::OptTable {
+public:
+  COFFLdOptTable() : OptTable(infoTable, false) {}
+  opt::InputArgList parse(ArrayRef<const char *> Argv);
+};
+
+} // namespace
+
+BumpPtrAllocator BAlloc;
+StringSaver Saver{BAlloc};
+static SmallVector<const char *, 256> LinkArgs;
+static std::vector<StringRef> SearchPaths;
+
+static void error(const Twine &Msg) {
+  errs() << Msg << "\n";
+  llvm_shutdown();
+  outs().flush();
+  errs().flush();
+  exit(1);
+}
+
+// Find a file by concatenating given paths.
+static Optional<std::string> findFile(StringRef Path1, const Twine &Path2) {
+  SmallString<128> S;
+  sys::path::append(S, Path1, Path2);
+  if (sys::fs::exists(S))
+    return S.str().str();
+  return None;
+}
+
+Optional<std::string> findFromSearchPaths(StringRef Path) {
+  for (StringRef Dir : SearchPaths)
+    if (Optional<std::string> S = findFile(Dir, Path))
+      return S;
+  return None;
+}
+
+// This is for -lfoo. We'll look for libfoo.dll.a or libfoo.a from search paths.
+Optional<std::string> searchLibrary(StringRef Name, bool IgnoreShared = false) {
+  if (Name.startswith(":"))
+    return findFromSearchPaths(Name.substr(1));
+  for (StringRef Dir : SearchPaths) {
+    if (!IgnoreShared)
+      if (Optional<std::string> S = findFile(Dir, "lib" + Name + ".dll.a"))
+        return S;
+    if (Optional<std::string> S = findFile(Dir, "lib" + Name + ".a"))
+      return S;
+  }
+  return None;
+}
+
+// Add a given library by searching it from input search paths.
+void addLibrary(StringRef Name, bool StaticOnly) {
+  if (Optional<std::string> Path = searchLibrary(Name, StaticOnly))
+    LinkArgs.push_back(Saver.save(*Path).data());
+  else
+    error("unable to find library -l" + Name);
+}
+
+void createFiles(opt::InputArgList &Args) {
+  for (auto *Arg : Args) {
+    switch (Arg->getOption().getID()) {
+    case OPT_l:
+      addLibrary(Arg->getValue(), Args.hasArg(OPT_Bstatic));
+      break;
+    case OPT_INPUT:
+      LinkArgs.push_back(Saver.save(Arg->getValue()).data());
+      break;
+    }
+  }
+}
+
+static std::vector<StringRef> getArgs(opt::InputArgList &Args, int Id) {
+  std::vector<StringRef> V;
+  for (auto *Arg : Args.filtered(Id))
+    V.push_back(Arg->getValue());
+  return V;
+}
+
+static void forward(opt::InputArgList &Args, unsigned Key, StringRef OutArg,
+                    const char *Default = nullptr) {
+  StringRef S = Args.getLastArgValue(Key);
+  if (S.size()) {
+    LinkArgs.push_back(Saver.save(Twine("-" + OutArg + ":" + S)).data());
+  } else if (Default) {
+    LinkArgs.push_back(
+        Saver.save(Twine("-" + OutArg + ":" + StringRef(Default))).data());
+  }
+}
+
+static void forwardValue(opt::InputArgList &Args, unsigned Key,
+                         StringRef CmpArg, StringRef OutArg,
+                         StringRef OutValueArg) {
+  StringRef S = Args.getLastArgValue(Key);
+  if (S == CmpArg)
+    LinkArgs.push_back(
+        Saver.save(Twine("-" + OutArg + ":" + OutValueArg)).data());
+}
+
+opt::InputArgList COFFLdOptTable::parse(ArrayRef<const char *> Argv) {
+  unsigned MissingIndex;
+  unsigned MissingCount;
+  SmallVector<const char *, 256> Vec(Argv.data(), Argv.data() + Argv.size());
+  opt::InputArgList Args = this->ParseArgs(Vec, MissingIndex, MissingCount);
+  if (MissingCount)
+    error(Twine(Args.getArgString(MissingIndex)) + ": missing argument");
+  if (!Args.hasArgNoClaim(OPT_INPUT) && !Args.hasArgNoClaim(OPT_l))
+    error("no input files");
+  for (auto *Arg : Args.filtered(OPT_UNKNOWN))
+    error("unknown argument: " + Arg->getSpelling());
+  return Args;
+}
+
+bool link(ArrayRef<const char *> ArgsArr, raw_ostream &Diag) {
+  COFFLdOptTable Parser;
+  opt::InputArgList Args = Parser.parse(ArgsArr.slice(1));
+  LinkArgs.push_back(ArgsArr[0]);
+
+  forwardValue(Args, OPT_m, "i386pe", "MACHINE", "X86");
+  forwardValue(Args, OPT_m, "i386pep", "MACHINE", "X64");
+  forwardValue(Args, OPT_m, "thumb2pe", "MACHINE", "ARM");
+  forwardValue(Args, OPT_m, "arm64pe", "MACHINE", "ARM64");
+
+  forward(Args, OPT_o, "OUT", "a.exe");
+  forward(Args, OPT_entry, "ENTRY");
+  forward(Args, OPT_subs, "SUBSYSTEM");
+  forward(Args, OPT_shared, "DLL");
+  forward(Args, OPT_outlib, "IMPLIB");
+  forward(Args, OPT_stack, "STACK");
+
+  SearchPaths = getArgs(Args, OPT_L);
+  createFiles(Args);
+
+  // handle __image_base__
+  auto M = Args.getLastArg(OPT_m);
+  if (M && StringRef(M->getValue()) == "i386pe")
+    LinkArgs.push_back("/alternatename:__image_base__=___ImageBase");
+  else
+    LinkArgs.push_back("/alternatename:__image_base__=__ImageBase");
+
+  return coff::link(LinkArgs);
+}
+
+} // namespace mingw
+} // namespace lld
diff --git a/MinGW/Options.td b/MinGW/Options.td
new file mode 100644
index 0000000..abf53c9
--- /dev/null
+++ b/MinGW/Options.td
@@ -0,0 +1,38 @@
+include "llvm/Option/OptParser.td"
+
+class F<string name>: Flag<["--", "-"], name>;
+class J<string name>: Joined<["--", "-"], name>;
+class S<string name>: Separate<["--", "-"], name>;
+
+def L: JoinedOrSeparate<["-"], "L">, MetaVarName<"<dir>">,
+  HelpText<"Add a directory to the library search path">;
+def entry: S<"entry">, MetaVarName<"<entry>">,
+  HelpText<"Name of entry point symbol">;
+def m: JoinedOrSeparate<["-"], "m">, HelpText<"Set target emulation">;
+def o: JoinedOrSeparate<["-"], "o">, MetaVarName<"<path>">,
+  HelpText<"Path to file to write output">;
+def l: JoinedOrSeparate<["-"], "l">, MetaVarName<"<libName>">,
+  HelpText<"Root name of library to use">;
+def shared: F<"shared">, HelpText<"Build a shared object">;
+def subs: Separate<["--"], "subsystem">, HelpText<"Specify subsystem">;
+def stack: Flag<["--"], "stack">, Alias<stack>;
+def outlib: Separate<["--"], "out-implib">, HelpText<"Import library name">;
+
+// Currently stubs to avoid errors
+def Bdynamic: F<"Bdynamic">, HelpText<"Link against shared libraries">;
+def Bstatic: F<"Bstatic">, HelpText<"Do not link against shared libraries">;
+def major_image_version: Separate<["--"], "major-image-version">;
+def minor_image_version: Separate<["--"], "minor-image-version">;
+def enable_auto_image_base: Flag<["--"], "enable-auto-image-base">;
+def full_shutdown: Flag<["--"], "full-shutdown">;
+def O: Joined<["-"], "O">, HelpText<"Optimize output file size">;
+def v: Flag<["-"], "v">, HelpText<"Display the version number">;
+def verbose: F<"verbose">, HelpText<"Verbose mode">;
+def version: F<"version">, HelpText<"Display the version number and exit">;
+
+// Alias
+def alias_entry_e: JoinedOrSeparate<["-"], "e">, Alias<entry>;
+
+// Style
+def rsp_quoting: J<"rsp-quoting=">,
+  HelpText<"Quoting style for response files. Values supported: windows|posix">;
diff --git a/include/lld/Driver/Driver.h b/include/lld/Driver/Driver.h
index 4ba0994..655fcfe 100644
--- a/include/lld/Driver/Driver.h
+++ b/include/lld/Driver/Driver.h
@@ -19,6 +19,11 @@ bool link(llvm::ArrayRef<const char *> Args,
           llvm::raw_ostream &Diag = llvm::errs());
 }
 
+namespace mingw {
+bool link(llvm::ArrayRef<const char *> Args,
+          llvm::raw_ostream &Diag = llvm::errs());
+}
+
 namespace elf {
 bool link(llvm::ArrayRef<const char *> Args, bool CanExitEarly,
           llvm::raw_ostream &Diag = llvm::errs());
diff --git a/test/COFF/out.test b/test/COFF/out.test
index a7b5614..976191c 100644
--- a/test/COFF/out.test
+++ b/test/COFF/out.test
@@ -4,14 +4,19 @@
 # RUN: cp %t.obj %T/out/out1.obj
 # RUN: cp %t.obj %T/out/tmp/out2
 # RUN: cp %t.obj %T/out/tmp/out3.xyz
+# RUN: cp %t.obj %T/out/out4.obj
 
 # RUN: rm -f out1.exe out2.exe out3.exe out3.dll
 # RUN: lld-link /entry:main %T/out/out1.obj
 # RUN: lld-link /entry:main %T/out/tmp/out2
 # RUN: lld-link /dll /entry:main %T/out/tmp/out3.xyz
 
+# RUN: rm -f a.exe
+# RUN: ld.lld -m i386pep --entry main %T/out/out4.obj
+
 # RUN: llvm-readobj out1.exe | FileCheck %s
 # RUN: llvm-readobj out2.exe | FileCheck %s
 # RUN: llvm-readobj out3.dll | FileCheck %s
+# RUN: llvm-readobj a.exe | FileCheck %s
 
 CHECK: File:
diff --git a/tools/lld/CMakeLists.txt b/tools/lld/CMakeLists.txt
index 2df1069..fc80fbd 100644
--- a/tools/lld/CMakeLists.txt
+++ b/tools/lld/CMakeLists.txt
@@ -10,6 +10,7 @@ target_link_libraries(lld
   lldDriver
   lldCOFF
   lldELF
+  lldMinGW
   )
 
 install(TARGETS lld
diff --git a/tools/lld/lld.cpp b/tools/lld/lld.cpp
index 09f8079..3b45aec 100644
--- a/tools/lld/lld.cpp
+++ b/tools/lld/lld.cpp
@@ -49,6 +49,16 @@ static Flavor getFlavor(StringRef S) {
       .Default(Invalid);
 }
 
+static bool isPETarget(const std::vector<const char *> &V) {
+  for (auto It = V.begin(); It + 1 != V.end(); ++It) {
+    if (StringRef(*It) != "-m")
+      continue;
+    StringRef S = *(It + 1);
+    return S == "i386pe" || S == "i386pep" || S == "thumb2pe" || S == "arm64pe";
+  }
+  return false;
+}
+
 static Flavor parseProgname(StringRef Progname) {
 #if __APPLE__
   // Use Darwin driver for "ld" on Darwin.
@@ -101,6 +111,8 @@ int main(int Argc, const char **Argv) {
   std::vector<const char *> Args(Argv, Argv + Argc);
   switch (parseFlavor(Args)) {
   case Gnu:
+    if (isPETarget(Args))
+      return !mingw::link(Args);
     return !elf::link(Args, true);
   case WinLink:
     return !coff::link(Args);
-- 
2.7.4

